# Конструкции в python

1. Условные конструкции

• if, elif, else: позволяют выполнять различные блоки кода в зависимости от условий.

```python
x = 10
if x > 0:
    print("Положительное число")
elif x < 0:
    print("Отрицательное число")
else:
    print("Ноль")
```

2. Циклы

• for: используется для итерации по элементам последовательностей (списки, строки, кортежи и т.д.).

• while: выполняет блок кода, пока условие истинно.

```python
# Цикл for
for i in range(5):
    print(i)

# Цикл while
count = 0
while count < 5:
    print(count)
    count += 1
```

3. Управляющие конструкции

• break: прерывает выполнение цикла.

• continue: пропускает текущую итерацию цикла и переходит к следующей.

• pass: является пустой операцией, которая не делает ничего. Используется как заполнитель.

Пример с использованием break

break используется для выхода из цикла. В следующем примере мы ищем первое число, которое делится на 7:

```python
for i in range(1, 20):
    if i % 7 == 0:
        print(f"Первое число, делящееся на 7: {i}")
        break  # Выход из цикла
```

Пример с использованием continue

continue пропускает текущую итерацию цикла и переходит к следующей. В этом примере мы выводим только четные числа от 1 до 10:

```python
for i in range(1, 11):
    if i % 2 != 0:
        continue  # Пропускаем нечетные числа
    print(i)  # Выводим только четные числа
```

Пример с использованием pass

pass используется как заполнитель, когда необходимо сохранить синтаксис, но нет никакой логики. Например, можно использовать pass, если вы хотите временно оставить пустой блок кода:

```python
for i in range(5):
    if i == 3:
        pass  # Здесь ничего не делаем, просто пропускаем
    else:
        print(i)  # Выводим все числа, кроме 3
```

Вот пример, где используются все три конструкции вместе:

```python
for i in range(1, 11):
    if i == 3:
        pass  # Ничего не делаем для числа 3
    elif i % 2 == 0:
        continue  # Пропускаем четные числа
    elif i == 9:
        break  # Выходим из цикла, когда встречаем 9
    print(i)  # Выводим только нечетные числа (кроме 3 и до 9)
```

4. Функции

• Определение функций с помощью ключевого слова def. Функции позволяют организовать код в логические блоки и повторно использовать его.

```python
# Определяем функцию, которая принимает два числа и возвращает их сумму
def add_numbers(a, b):
    return a + b

# Вызываем функцию и выводим результат
result = add_numbers(5, 3)
print(f"Сумма: {result}")  # Вывод: Сумма: 8
```

5. Исключения

• try, except, finally: используются для обработки ошибок и исключений, позволяя программе продолжать выполнение даже при возникновении ошибок.

```python
try:
    # Попытка деления на ноль
    result = 10 / 0
except ZeroDivisionError:
    print("Ошибка: Деление на ноль!")  # Обработка исключения
finally:
    print("Этот блок выполняется всегда.")  # Выполняется всегда

# Вывод:
# Ошибка: Деление на ноль!
# Этот блок выполняется всегда.
```

6. Контекстные менеджеры

• Используются с ключевым словом with для управления ресурсами (например, открытие и закрытие файлов).

```python
# Используем контекстный менеджер with для работы с файлом
with open('example.txt', 'w') as file:
    file.write("Привет, мир!")  # Запись в файл

# Файл автоматически закрывается после выхода из блока with
print("Файл записан и закрыт.")
```

7. Лямбда-функции

• Анонимные функции, которые можно создавать с помощью ключевого слова lambda. Они могут принимать любое количество аргументов, но могут содержать только одно выражение.

```python
# Лямбда-функция для сложения двух чисел
add = lambda x, y: x + y

# Используем лямбда-функцию
result = add(5, 3)
print(f"Сумма: {result}")  # Вывод: Сумма: 8

# Лямбда-функция для возведения в квадрат
square = lambda x: x ** 2
print(f"Квадрат 4: {square(4)}")  # Вывод: Квадрат 4: 16
```

8. Генераторы и итераторы

• Генераторы позволяют создавать итераторы с помощью функции и ключевого слова yield. Это позволяет возвращать значения по одному, не сохраняя все значения в памяти.

```python
# Генератор для создания последовательности квадратов чисел
def generate_squares(n):
    for i in range(n):
        yield i ** 2

# Используем генератор
squares = generate_squares(5)
for square in squares:
    print(square)  # Вывод: 0, 1, 4, 9, 16
```

9. Списковые включения (List Comprehensions)

• Списковые включения позволяют создавать списки с использованием компактного синтаксиса. Это упрощает создание новых списков на основе существующих.

```python
# Создаем список квадратов чисел от 0 до 9 с помощью спискового включения
squares = [x ** 2 for x in range(10)]
print(squares)  # Вывод: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Списковое включение с условием: создаем список четных квадратов
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
print(even_squares)  # Вывод: [0, 4, 16, 36, 64]
```

10. Модули и пакеты

• Позволяют организовывать код в модули и пакеты, что упрощает управление большими проектами.

## Условные операторы

### if - elif - else

1. Оператор if

С помощью оператора if можно проверить условие и выполнить блок кода, если это условие истинно (True):

```python
x = 10

if x > 5:
    print("x больше 5")
```

2. Оператор else

Оператор else позволяет выполнить блок кода, если условие в if ложно (False):

```python
x = 3

if x > 5:
    print("x больше 5")
else:
    print("x не больше 5")
```

3. Оператор elif

Оператор elif (сокращение от "else if") позволяет проверить несколько условий последовательно:

```python
x = 5

if x > 5:
    print("x больше 5")
elif x == 5:
    print("x равно 5")
else:
    print("x меньше 5")
```

4. Логические операторы

Вы можете комбинировать условия с помощью логических операторов: and, or, not.

• and: возвращает True, если оба условия истинны.

• or: возвращает True, если хотя бы одно из условий истинно.

• not: инвертирует значение условия.

```python
x = 10
y = 20

if x > 5 and y > 15:
    print("Оба условия истинны")

if x > 15 or y > 15:
    print("Хотя бы одно условие истинно")

if not (x < 5):
    print("x не меньше 5")
```

Вложенные условные операторы

Условные операторы могут быть вложенными, то есть вы можете использовать один оператор внутри другого:

```python
x = 10

if x > 0:
    print("x положительное число")
    if x % 2 == 0:
        print("x четное число")
    else:
        print("x нечетное число")
else:
    print("x отрицательное число или ноль")
```

6. Условные выражения (тернарный оператор)

Python также поддерживает тернарный оператор, который позволяет записывать условные выражения в более компактной форме:

```python
x = 10
result = "Положительное" if x > 0 else "Отрицательное или ноль"
print(result)
```

### match - case

    Конструкция match-case в Python была введена в версии 3.10 и представляет собой мощный инструмент для сопоставления структур данных с шаблонами. Она позволяет более элегантно и читаемо обрабатывать различные случаи, чем традиционные условные операторы if-elif-else. Это особенно полезно при работе с сложными структурами данных, такими как кортежи, списки и словари.

Основной синтаксис

Конструкция match-case имеет следующий синтаксис:

```python
match выражение:
    case шаблон1:
        # код для шаблона 1
    case шаблон2:
        # код для шаблона 2
    case _:
        # код по умолчанию (аналог else)
```

Пример использования

Рассмотрим простой пример, где мы будем использовать match-case для обработки различных типов данных:

```python
def describe(value):
    match value:
        case 0:
            return "Это ноль"
        case 1:
            return "Это единица"
        case 2 | 3 | 4:
            return "Это число от 2 до 4"
        case _:
            return "Это другое число"

print(describe(0))  # Это ноль
print(describe(1))  # Это единица
print(describe(3))  # Это число от 2 до 4
print(describe(10)) # Это другое число
```

Шаблоны

В match-case можно использовать различные типы шаблонов:

1. Литералы: Можно сопоставлять с конкретными значениями, как в примере выше.
   
2. Комбинирование условий: Можно использовать оператор | для объединения нескольких условий:

```python
   match value:
       case 1 | 2 | 3:
           print("Число от 1 до 3")
   
```

Позиционные шаблоны: Можно сопоставлять кортежи:

```python
   def process_point(point):
       match point:
           case (x, y):
               print(f"Точка с координатами: ({x}, {y})")
           case _:
               print("Неизвестная точка")

   process_point((10, 20))  # Точка с координатами: (10, 20)
```

Шаблоны с именами: Можно присваивать значения переменным внутри шаблонов:

```python
   match value:
       case (x, y):
           print(f"x: {x}, y: {y}")
       case _:
           print("Неизвестный формат")
   
```

Структурные шаблоны: Можно сопоставлять более сложные структуры, такие как списки и словари:

```python
   def process_data(data):
       match data:
           case {"name": name, "age": age}:
               print(f"Имя: {name}, Возраст: {age}")
           case _:
               print("Неизвестные данные")

   process_data({"name": "Alice", "age": 30})  # Имя: Alice, Возраст: 30
```

    В Python литералы — это фиксированные значения, которые напрямую записываются в коде. Они представляют собой данные, которые не требуют вычислений или дополнительных операций для определения их значения. Литералы могут быть разных типов, включая:

1. Числовые литералы:

   • Целые числа: Например, 10, -5, 0.

   • Числа с плавающей точкой: Например, 3.14, -0.001, 2.0.

```python
   a = 10          # целый литерал
   b = 3.14        # литерал с плавающей точкой
```
2. Строковые литералы:

   • Строки могут быть заключены в одинарные ('...') или двойные ("...") кавычки. Также существуют многострочные строки, которые заключаются в тройные кавычки ('''...''' или """...""").

```python
   name = "Alice"           # строковый литерал
   greeting = '''Hello!'''  # многострочный строковый литерал
```

3. Логические литералы:

   • В Python есть два логических литерала: True и False.

```python
   is_active = True       # логический литерал
   is_deleted = False     # логический литерал
```

4. Специальный литерал:

   • None — это специальный литерал, который используется для обозначения отсутствия значения.

```python
   result = None          # специальный литерал
```

5. Списковые и кортежные литералы:

   • Списки и кортежи также могут быть созданы с помощью литералов.

```python
   my_list = [1, 2, 3]       # литерал списка
   my_tuple = (1, 2, 3)      # литерал кортежа
   
```

6. Словарные литералы:

   • Словари создаются с помощью фигурных скобок {}.

```python
   my_dict = {"name": "Alice", "age": 30}  # литерал словаря
```

Примеры

Вот несколько примеров использования различных типов литералов:

```python
# Числовые литералы
x = 42
pi = 3.14159

# Строковые литералы
message = "Hello, World!"

# Логические литералы
is_valid = True

# Специальный литерал
data = None

# Списковые и кортежные литералы
numbers = [1, 2, 3, 4]
coordinates = (10, 20)

# Словарные литералы
person = {"name": "Bob", "age": 25}
```

## Циклы
### for

Цикл for используется для итерации по элементам последовательностей, таких как списки, кортежи, строки или диапазоны.

Синтаксис:

```python
for элемент in последовательность:
    # код, который будет выполняться для каждого элемента
```
Пример:
```python
# Итерация по списку
fruits = ["яблоко", "банан", "вишня"]
for fruit in fruits:
    print(fruit)

# Итерация по диапазону
for i in range(5):
    print(i)
```

### while

Цикл while выполняет блок кода, пока условие истинно.

Синтаксис:

```python
while условие:
    # код, который будет выполняться, пока условие истинно
```

Пример:

```python
# Пример использования цикла while
count = 0
while count < 5:
    print(count)
    count += 1  # Увеличиваем счетчик на 1
```

### Управляющие конструкции в циклах

1. break

Команда break используется для выхода из цикла досрочно.

```python
for i in range(10):
    if i == 5:
        break
    print(i)  # Выводит числа от 0 до 4
```

2. continue

Команда continue пропускает текущую итерацию и переходит к следующей.

```python
for i in range(5):
    if i == 2:
        continue  # Пропускаем 2
    print(i)  # Выводит 0, 1, 3, 4
```

### Вложенные циклы

Вы можете использовать циклы внутри других циклов.

```python
for i in range(3):
    for j in range(2):
        print(f"i = {i}, j = {j}")
```

В Python есть несколько специфических особенностей и отличий в работе с циклами по сравнению с другими языками программирования. Вот некоторые из них:

1. Индексация и диапазоны

• Индексация начинается с нуля: В Python индексация элементов в последовательностях (списки, кортежи, строки) начинается с нуля. Это важно учитывать при использовании циклов.

• Функция range(): В Python функция range() используется для генерации последовательности чисел. Она возвращает объект, который генерирует числа от начального до конечного значения (не включая его). Например, range(5) создаст последовательность [0, 1, 2, 3, 4].

2. Генераторы и итераторы

• Итераторы: В Python многие встроенные объекты (например, списки и кортежи) являются итерируемыми, что позволяет использовать их в циклах for напрямую.

• Генераторы: Вы можете создавать генераторы с помощью выражений-генераторов или функции yield. Это позволяет экономить память при работе с большими объемами данных.

```python
def my_generator():
    for i in range(5):
        yield i

for value in my_generator():
    print(value)
```

3. Параллельные циклы с zip()

• Функция zip(): Позволяет объединять несколько последовательностей в одну, что удобно при параллельной итерации.

```python
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]

for name, age in zip(names, ages):
    print(f"{name} is {age} years old.")
```

4. Использование else с циклами

• else после цикла: В Python вы можете использовать блок else после цикла. Этот блок выполняется, если цикл завершился нормально (т.е. не был прерван командой break).

```python
for i in range(5):
    print(i)
else:
    print("Цикл завершен успешно.")
```

5. Лямбда-функции и функции высшего порядка

• Вы можете использовать функции высшего порядка (такие как map(), filter(), и reduce()) для обработки последовательностей без явного написания циклов.

```python
squared = list(map(lambda x: x**2, range(5)))
print(squared)  # Вывод: [0, 1, 4, 9, 16]
```

## Функции

1. Определение функции

Функции определяются с помощью ключевого слова def, за которым следует имя функции, круглые скобки (в которых могут быть указаны параметры) и двоеточие. Затем идет блок кода, который будет выполняться при вызове функции.

```python
def greet(name):
    print(f"Hello, {name}!")
```

2. Вызов функции

Чтобы вызвать функцию, просто используйте ее имя и передайте необходимые аргументы:

```python
greet("Alice")  # Вывод: Hello, Alice!
```

3. Аргументы функции

Функции могут принимать аргументы различными способами:

• Обязательные аргументы: Аргументы, которые необходимо передать при вызове функции.

  
• Аргументы по умолчанию: Аргументы, которые имеют значения по умолчанию, если они не указаны при вызове.

```python
def greet(name="Guest"):
    print(f"Hello, {name}!")

greet()          # Вывод: Hello, Guest!
greet("Bob")    # Вывод: Hello, Bob!
```

• Неопределенное количество аргументов: Вы можете использовать *args для передачи произвольного количества позиционных аргументов и **kwargs для передачи произвольного количества именованных аргументов.

```python
def print_args(*args):
    for arg in args:
        print(arg)

print_args(1, 2, 3)  # Вывод: 1 2 3

def print_kwargs(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_kwargs(name="Alice", age=30)  # Вывод: name: Alice, age: 30
```

4. Возврат значений

Функции могут возвращать значения с помощью ключевого слова return. Если return не указан, функция возвращает None.

```python
def add(a, b):
    return a + b

result = add(5, 3)
print(result)  # Вывод: 8
```

5. Лямбда-функции

Лямбда-функции — это анонимные функции, которые можно создавать на лету. Они обычно используются для простых операций.

```python
square = lambda x: x ** 2
print(square(5))  # Вывод: 25
```

6. Область видимости переменных

Переменные, объявленные внутри функции, имеют локальную область видимости и недоступны вне функции. Переменные вне функции имеют глобальную область видимости.

```python
x = "global"

def func():
    x = "local"
    print(x)

func()  # Вывод: local
print(x)  # Вывод: global
```

7. Докстринги

Докстринги — это строки документации, которые можно добавлять в начало функции для описания ее назначения и использования. Они доступны через атрибут __doc__.

```python
def multiply(a, b):
    """Умножает два числа."""
    return a * b

print(multiply.__doc__)  # Вывод: Умножает два числа.
```

8. Декораторы

Декораторы — это специальные функции, которые позволяют изменять поведение других функций. Они часто используются для добавления функциональности, такой как логирование или проверка прав доступа.

```python
def decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@decorator
def say_hello():
    print("Hello!")

say_hello()
```

## Исключения

### try - except - finaly / else

Исключения в Python — это механизм обработки ошибок, который позволяет программе реагировать на различные ошибки и исключительные ситуации, не прерывая ее выполнение. Исключения могут возникать по разным причинам, например, при делении на ноль, попытке доступа к несуществующему элементу списка или при работе с файлами.

Основные концепции исключений

1. Исключение: Это объект, который представляет собой ошибку или необычное состояние. В Python есть множество встроенных исключений, таких как ZeroDivisionError, IndexError, KeyError, TypeError и многие другие.

2. Обработка исключений: Для обработки исключений используется конструкция try...except. Код, который может вызвать исключение, помещается в блок try, а обработка исключения — в блоке except.

Пример обработки исключений

Вот простой пример обработки исключения:

```python
try:
    result = 10 / 0  # Это вызовет ZeroDivisionError
except ZeroDivisionError:
    print("Ошибка: Деление на ноль!")
```

Множественные исключения

Вы можете обрабатывать несколько типов исключений, используя несколько блоков except или объединяя их в одном блоке:

```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
except ZeroDivisionError:
    print("Ошибка: Деление на ноль!")
except ValueError:
    print("Ошибка: Введено не число!")
```

Блок else

Блок else можно использовать после блоков try и except. Код в блоке else выполняется, если не было вызвано никаких исключений.

```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
except ZeroDivisionError:
    print("Ошибка: Деление на ноль!")
except ValueError:
    print("Ошибка: Введено не число!")
else:
    print(f"Результат: {result}")
```

Блок finally

Блок finally выполняется всегда, независимо от того, было ли исключение или нет. Это полезно для освобождения ресурсов (например, закрытия файлов).

```python
try:
    file = open('example.txt', 'r')
    content = file.read()
except FileNotFoundError:
    print("Ошибка: Файл не найден!")
finally:
    file.close()  # Этот код выполнится всегда
```

Создание собственных исключений

Вы также можете создавать свои собственные классы исключений, наследуя от класса Exception. Это полезно для создания специфичных для вашей программы ошибок.

```python
class MyCustomError(Exception):
    pass

def check_value(x):
    if x < 0:
        raise MyCustomError("Значение не может быть отрицательным!")

try:
    check_value(-1)
except MyCustomError as e:
    print(e)  # Вывод: Значение не может быть отрицательным!
```

## Контекстные менеджеры

Контекстные менеджеры в Python — это удобный способ управления ресурсами, такими как файлы, сетевые соединения или блокировки. Они позволяют автоматически выполнять определенные действия при входе и выходе из блока кода, что особенно полезно для освобождения ресурсов или обработки ошибок.

Основные концепции контекстных менеджеров

1. Контекстный менеджер: Это объект, который определяет методы __enter__() и __exit__(). Метод __enter__() выполняется перед началом блока кода, а метод __exit__() — после его завершения (независимо от того, произошло ли исключение).

2. Оператор with: Контекстные менеджеры обычно используются с оператором with, который обеспечивает правильное управление ресурсами.

Пример использования с файлами

Наиболее распространенный пример контекстного менеджера — работа с файлами. Вот как это выглядит:

```python
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
# Файл автоматически закрывается после выхода из блока with
```

В этом примере файл example.txt открывается для чтения, и после завершения блока with файл автоматически закрывается, даже если в процессе чтения произошла ошибка.

Создание собственного контекстного менеджера

Вы можете создать собственный контекстный менеджер, определив класс с методами __enter__ и __exit__. Вот пример:

```python
class MyContextManager:
    def __enter__(self):
        print("Вход в контекст")
        return self  # Можно вернуть объект, который будет доступен внутри блока with

    def __exit__(self, exc_type, exc_value, traceback):
        print("Выход из контекста")
        if exc_type:
            print(f"Произошла ошибка: {exc_value}")
        return True  # Если вернуть True, исключение будет подавлено

with MyContextManager() as manager:
    print("Внутри контекста")
    # raise ValueError("Тестовая ошибка")  # Раскомментируйте для проверки обработки исключений
```

Использование функции contextlib

Python также предоставляет модуль contextlib, который позволяет создавать контекстные менеджеры с помощью декораторов и генераторов. Например, можно использовать декоратор contextmanager для упрощения создания контекстного менеджера:

```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print("Вход в контекст")
    yield  # Здесь можно вернуть значение, доступное внутри блока with
    print("Выход из контекста")

with my_context():
    print("Внутри контекста")
```

Преимущества использования контекстных менеджеров

1. Упрощение кода: Контекстные менеджеры делают код чище и более читаемым, устраняя необходимость вручную управлять ресурсами.

2. Автоматическое управление ресурсами: Они гарантируют, что ресурсы будут освобождены даже в случае возникновения исключений.

3. Четкое разделение логики: Контекстные менеджеры помогают отделить логику работы с ресурсами от основной бизнес-логики программы.


## Анонимные функции

Лямбда-функции в Python — это небольшие анонимные функции, которые создаются с помощью ключевого слова lambda. Они могут принимать любое количество аргументов, но могут содержать только одно выражение. Лямбда-функции часто используются в ситуациях, когда требуется передать функцию в качестве аргумента, например, в функции map(), filter() и sorted().

Синтаксис

Синтаксис лямбда-функции выглядит следующим образом:

```python
lambda аргументы: выражение
```
Примеры использования

1. Простая лямбда-функция:

```python
# Лямбда-функция, которая добавляет 10 к переданному числу
add_ten = lambda x: x + 10
print(add_ten(5))  # Вывод: 15
```

2. Лямбда-функция с несколькими аргументами:
```python
# Лямбда-функция, которая умножает два числа
multiply = lambda x, y: x * y
print(multiply(3, 4))  # Вывод: 12
```
3. Использование с функцией map():

```python
# Применение лямбда-функции для возведения в квадрат всех элементов списка
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # Вывод: [1, 4, 9, 16]
```
4. Использование с функцией filter():
```python
# Фильтрация четных чисел из списка
numbers = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # Вывод: [2, 4, 6]
```
5. Использование с функцией sorted():
```python
# Сортировка списка кортежей по второму элементу
data = [(1, 'one'), (3, 'three'), (2, 'two')]
sorted_data = sorted(data, key=lambda x: x[1])
print(sorted_data)  # Вывод: [(1, 'one'), (3, 'three'), (2, 'two')]
```
Ограничения

• Лямбда-функции могут содержать только одно выражение и не могут содержать многострочный код.

• Они обычно менее читаемы по сравнению с обычными функциями, особенно если используются в сложных операциях.

• Использование лямбда-функций может затруднить отладку кода.


## Генераторы и итераторы
Генераторы и итераторы — это важные концепции в Python, которые позволяют работать с последовательностями данных более эффективно и удобно. Давайте рассмотрим каждую из этих концепций подробнее.

▎Итераторы

Итератор — это объект, который позволяет перебирать элементы коллекции (например, списка, кортежа или словаря) по одному за раз. Итераторы реализуют два метода:

1. __iter__(): возвращает сам итератор.

2. __next__(): возвращает следующий элемент из последовательности. Если элементов больше нет, вызывается исключение StopIteration.

▎Пример создания итератора

```python
class MyIterator:
    def __init__(self, max):
        self.max = max
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < self.max:
            result = self.current
            self.current += 1
            return result
        else:
            raise StopIteration

# Использование итератора
iterator = MyIterator(5)
for num in iterator:
    print(num)  # Вывод: 0, 1, 2, 3, 4
```

▎Генераторы

Генераторы — это специальный вид итераторов, которые позволяют создавать итераторы проще и удобнее. Генераторы определяются с помощью функции, в которой используется оператор yield. Когда функция с yield вызывается, она возвращает значение и "замораживает" свое состояние, чтобы продолжить выполнение при следующем вызове.

▎Пример генератора

```python
def my_generator(max):
    current = 0
    while current < max:
        yield current
        current += 1

# Использование генератора
gen = my_generator(5)
for num in gen:
    print(num)  # Вывод: 0, 1, 2, 3, 4
```

Преимущества генераторов

1. Экономия памяти: Генераторы создают элементы по одному и не хранят всю последовательность в памяти, что позволяет работать с большими объемами данных.

2. Удобство написания: Код с использованием генераторов обычно короче и понятнее по сравнению с реализацией итераторов через классы.

3. Ленивая оценка: Генераторы вычисляют значения только по мере необходимости, что может повысить производительность.

▎Итерация по генераторам

Генераторы можно использовать в любых контекстах, где ожидается итератор:

• В циклах for

• В функциях list(), set(), dict()

• В функциях map(), filter(), и других


## Списковые включения

    Списковые включения (или генераторы списков) в Python — это удобный и лаконичный способ создания списков. Они позволяют создавать новые списки, применяя выражения к элементам существующих последовательностей (например, списков, кортежей или строк) и фильтруя их по определённым условиям.

Синтаксис

Списковое включение имеет следующий синтаксис:
```python
[выражение for элемент in последовательность if условие]
```
• выражение: выражение, которое будет вычислено для каждого элемента.

• элемент: переменная, представляющая текущий элемент из последовательности.

• последовательность: любая итерируемая коллекция (список, строка и т.д.).

• условие (необязательный): условие, по которому элементы будут включены в новый список.

Примеры использования

1. Создание списка квадратов чисел:

```python
squares = [x**2 for x in range(10)]
print(squares)  # Вывод: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```
2. Фильтрация элементов:

```python
evens = [x for x in range(20) if x % 2 == 0]
print(evens)  # Вывод: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```
3. Преобразование строк:

```python
words = ["hello", "world", "python"]
upper_words = [word.upper() for word in words]
print(upper_words)  # Вывод: ['HELLO', 'WORLD', 'PYTHON']
```
4. Сложные выражения:

```python
pairs = [(x, y) for x in range(3) for y in range(3)]
print(pairs)  # Вывод: [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
```
Преимущества списковых включений

1. Краткость: Списковые включения позволяют сократить код и сделать его более читаемым.

2. Производительность: Генерация списков с помощью списковых включений часто быстрее, чем использование цикла for, поскольку они оптимизированы на уровне языка.

Недостатки

1. Сложность: Если выражение становится слишком сложным или содержит много условий, это может снизить читаемость кода.

2. Память: Списковые включения создают весь список сразу в памяти. Для очень больших данных это может быть проблемой. В таких случаях лучше использовать генераторы.


## Модули и пакеты

▎Пример создания и использования модуля

1. Создайте файл модуля. Назовем его mymodule.py

```python
# mymodule.py

def greet(name):
    return f"Привет, {name}!"

def add(a, b):
    return a + b
```

2. Используйте модуль в другом файле. Создайте файл, например, main.py

```python
# main.py

# Импортируем функции из модуля
from mymodule import greet, add

# Используем функции из модуля
name = "Алексей"
print(greet(name))  # Вывод: Привет, Алексей!

result = add(5, 7)
print(f"Сумма: {result}")  # Вывод: Сумма: 12
```

Запуск программы

Теперь вы можете запустить main.py, и он будет использовать функции из вашего модуля mymodule.py.

Альтернативный способ импорта

Вы также можете импортировать весь модуль целиком:

```python
# main.py

import mymodule

print(mymodule.greet("Анна"))  # Вывод: Привет, Анна!
print(f"Сумма: {mymodule.add(3, 4)}")  # Вывод: Сумма: 7
```