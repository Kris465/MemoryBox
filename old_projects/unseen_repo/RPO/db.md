# Базы данных

1. Dbeaver.
https://mariadb.org/download/?t=mariadb&p=mariadb&r=11.7.2&os=windows&cpu=x86_64&pkg=msi&mirror=docker_ru

https://dbeaver.io/download/

## Немного про ООП в python

    ООП - объектно-ориентированное программирование. Парадигма программирования, которая позволяет организовывать код, ориентируясь на "объекты".

1. Класс:

   • Шаблон или чертеж для создания объектов.

   • Определяет свойства (атрибуты) и методы (функции), которые будут у объектов этого класса.

2. Объект:

   • Конкретный экземпляр класса.

   • Содержит данные и методы, определенные в классе.

3. Инкапсуляция:

   • Скрытие внутренней реализации объекта и предоставление доступа только через публичные методы.

   • Позволяет защищать данные и управлять доступом к ним.

4. Наследование:

   • Возможность создавать новый класс на основе существующего.

   • Новый класс (подкласс) наследует атрибуты и методы родительского класса (суперкласса).

   • Позволяет повторно использовать код и расширять функциональность.

5. Полиморфизм:

   • Способность объектов разных классов обрабатывать одинаковые операции по-разному.

   • Позволяет использовать один интерфейс для работы с разными типами объектов.

```python
# Определяем класс Animal
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

# Определяем подкласс Dog
class Dog(Animal):
    def speak(self):
        return f"{self.name} says Woof!"

# Определяем подкласс Cat
class Cat(Animal):
    def speak(self):
        return f"{self.name} says Meow!"

# Создаем объекты
dog = Dog("Buddy")
cat = Cat("Whiskers")

# Вызываем методы
print(dog.speak())  # Вывод: Buddy says Woof!
print(cat.speak())  # Вывод: Whiskers says Meow!
```

▎Дополнительные аспекты:

• Атрибуты класса и экземпляра:

  • Атрибуты класса общие для всех экземпляров, а атрибуты экземпляра уникальны для каждого объекта.

• Методы класса и статические методы:

  • Методы класса принимают ссылку на класс в качестве первого аргумента (обычно cls).

  • Статические методы не зависят от состояния экземпляра или класса и могут быть вызваны без создания объекта.

• Магические методы:

  • Специальные методы, начинающиеся и заканчивающиеся двойными подчеркиваниями (например, __init__, __str__, __repr__), которые позволяют определять поведение объектов при различных операциях.

https://python.swaroopch.com/oop.html

## Практическое задание на примитивную БД.

https://www.52shuku.vip/yanqing/am/h2QX.html

Написать парсер с помощью классов, записать в json все главы новеллы. Для проверки прочитать выданный json-файл.

## Немного про базы данных

Существует множество типов баз данных, каждая из которых имеет свои особенности и предназначение. Вот основные категории баз данных:

▎1. Реляционные базы данных (RDBMS)

Эти базы данных организуют данные в таблицы, которые могут быть связаны друг с другом. Они используют язык SQL (Structured Query Language) для управления данными.

• Примеры:

  • MySQL

  • PostgreSQL

  • Oracle Database

  • Microsoft SQL Server

▎2. Нереляционные базы данных (NoSQL)

Эти базы данных не используют фиксированную схему и могут хранить данные в различных форматах, таких как документы, графы или ключ-значение.

• Типы:

  • Документные базы данных: хранят данные в формате документов (например, JSON).

    • Примеры: MongoDB, CouchDB.

  
  • Графовые базы данных: оптимизированы для работы с графами и связями между данными.

    • Примеры: Neo4j, ArangoDB.

  
  • Ключ-значение: хранят данные в виде пар ключ-значение.

    • Примеры: Redis, Amazon DynamoDB.

  
  • Столбцовые базы данных: хранят данные в столбцах, что позволяет эффективно обрабатывать большие объемы данных.

    • Примеры: Apache Cassandra, HBase.

▎3. Объектно-ориентированные базы данных

Эти базы данных хранят данные в виде объектов, как в объектно-ориентированном программировании.

• Примеры:

  • ObjectDB

  • db4o

▎4. Временные базы данных

Эти базы данных специализируются на хранении временных данных и обеспечивают поддержку временных аспектов.

• Примеры:

  • TimescaleDB (расширение для PostgreSQL)

  • InfluxDB

▎5. Распределенные базы данных

Эти базы данных распределяют данные по нескольким узлам или серверам, что обеспечивает высокую доступность и отказоустойчивость.

• Примеры:

  • Apache Cassandra

  • Google Spanner

▎6. Облачные базы данных

Эти базы данных размещаются в облаке и предоставляют доступ через интернет. Они могут быть как реляционными, так и нереляционными.

• Примеры:

  • Amazon RDS (реляционные)

  • Firebase Firestore (документные)

▎7. Базы данных в памяти

Эти базы данных хранят данные в оперативной памяти для обеспечения высокой скорости доступа.

• Примеры:

  • Redis

  • Memcached

## Реляционные базы данных

Реляционные базы данных (RDBMS) — это один из самых популярных и широко используемых типов баз данных. Они организуют данные в таблицы, которые могут быть связаны друг с другом, что позволяет эффективно управлять и извлекать данные. Давайте рассмотрим основные аспекты реляционных баз данных.

RDBMS расшифровывается как Relational Database Management System, что на русском языке означает Система Управления Реляционными Базами Данных. Это программное обеспечение, которое позволяет пользователям создавать, управлять и манипулировать реляционными базами данных. RDBMS обеспечивает структурированное хранение данных в виде таблиц и поддерживает операции с ними с помощью языка SQL.

▎Основные характеристики реляционных баз данных:

1. Структурированные данные:

   • Данные хранятся в виде таблиц, состоящих из строк и столбцов. Каждая строка представляет собой запись (или запись), а каждый столбец — атрибут записи.

2. Схема:

   • Реляционные базы данных имеют фиксированную схему, что означает, что структура таблиц (количество и типы столбцов) должна быть определена заранее.

3. Связи между таблицами:

   • Таблицы могут быть связаны друг с другом с помощью первичных и внешних ключей. Первичный ключ уникально идентифицирует каждую запись в таблице, а внешний ключ используется для создания связи с другой таблицей.

4. Язык SQL:

   • Для работы с реляционными базами данных используется язык SQL (Structured Query Language). SQL позволяет выполнять операции создания, чтения, обновления и удаления данных (CRUD).

5. Транзакции:

   • Реляционные базы данных поддерживают транзакции, что позволяет выполнять несколько операций как единое целое. Это обеспечивает целостность данных и защиту от ошибок.

6. Нормализация:

   • Процесс нормализации используется для организации данных в базе данных с целью минимизации дублирования и обеспечения целостности данных.

▎Примеры реляционных баз данных:

• MySQL: Одна из самых популярных реляционных баз данных с открытым исходным кодом, часто используемая для веб-приложений.

• PostgreSQL: Мощная реляционная база данных с поддержкой расширенных функций, таких как работа с JSON и полнотекстовый поиск.

• Oracle Database: Коммерческая реляционная база данных, известная своей надежностью и масштабируемостью.

• Microsoft SQL Server: Реляционная база данных от Microsoft, популярная в корпоративной среде.

▎Применение реляционных баз данных:

• Веб-приложения: Многие веб-приложения используют реляционные базы данных для хранения пользовательских данных, контента и других структурированных данных.

• Финансовые системы: Реляционные базы данных часто используются в банковских и финансовых системах для управления транзакциями и учета.

• Управление запасами: В системах управления запасами реляционные базы данных помогают отслеживать товары, их количество и местоположение.

▎Преимущества реляционных баз данных:

• Строгая структура: Ясная структура и схема обеспечивают целостность и согласованность данных.

• Поддержка сложных запросов: SQL позволяет выполнять сложные запросы для извлечения и анализа данных.

• Транзакционная безопасность: Поддержка транзакций гарантирует целостность данных.

▎Недостатки реляционных баз данных:

• Ограниченная гибкость схемы: Изменение структуры таблиц может быть сложным и требовать миграции данных.

• Производительность при больших объемах данных: При работе с очень большими объемами данных реляционные базы могут испытывать проблемы с производительностью.

## Блок-схемы баз данных

Связи между таблицами в реляционных базах данных.

1. Один к одному (1:1):

   • В этой связи каждой записи в первой таблице соответствует ровно одна запись во второй таблице и наоборот. Например, каждый человек может иметь только один паспорт, и каждый паспорт принадлежит только одному человеку.

2. Один ко многим (1:N):

   • В этой связи одной записи в первой таблице может соответствовать множество записей во второй таблице, но каждой записи во второй таблице соответствует только одна запись в первой таблице. Например, один автор может написать несколько книг, но каждая книга имеет только одного автора.

3. Многие к одному (N:1):

   • Это обратная связь к связи "один ко многим". Здесь множество записей в первой таблице могут соответствовать одной записи во второй таблице. Например, множество сотрудников может работать в одном отделе.

4. Многие ко многим (N:M):

   • В этой связи множество записей в первой таблице могут соответствовать множеству записей во второй таблице. Для реализации такой связи обычно создается промежуточная таблица (или ассоциативная таблица), которая содержит внешние ключи на обе таблицы. Например, студенты могут записываться на множество курсов, а каждый курс может иметь множество студентов.

▎Примеры:

• Один к одному: 

  • Таблицы: Пользователи и Профили.

  
• Один ко многим:

  • Таблицы: Авторы и Книги.

• Многие к одному:

  • Таблицы: Заказы и Клиенты.

• Многие ко многим:

  • Таблицы: Студенты, Курсы и промежуточная таблица Записи (содержит идентификаторы студентов и курсов).

Эти связи помогают организовать данные в реляционных базах данных, обеспечивая целостность и структуру информации.

## Практическое задание на связи в реляционной бд

Давайте разработаем практическое задание, которое поможет вам создать блок-схему базы данных и визуализировать различные виды связей между таблицами.

▎Пример таблиц для школьной базы данных

1. Таблица Students (Студенты)

   • Student_ID (ID студента)

   • Name (Имя)

   • Age (Возраст)

2. Таблица Classes (Классы)

   • Class_ID (ID класса)

   • Class_Name (Название класса)

   • Teacher_ID (ID учителя)

3. Таблица Teachers (Учителя)

   • Teacher_ID (ID учителя)

   • Name (Имя)

   • Subject (Предмет)

4. Таблица Enrollments (Записи на занятия) — связь многие ко многим

   • Enrollment_ID (ID записи)

   • Student_ID (ID студента)

   • Class_ID (ID класса)

▎Связи:

• Students ↔️ Enrollments: Один студент может быть записан на несколько классов (1:N).

• Classes ↔️ Enrollments: Один класс может содержать много студентов (1:N).

• Teachers ↔️ Classes: Один учитель может вести несколько классов (1:N).

▎2. Блок-схема при проектировании БД

Блок-схема помогает визуализировать структуру базы данных и связи между таблицами. Вот пример, как это может выглядеть:

```copy

+----------------+         +-----------------+
|    Students    |         |     Teachers     |
|----------------|         |------------------|
| Student_ID     |         | Teacher_ID       |
| Name           |         | Name             |
| Age            |         | Subject          |
+----------------+         +------------------+
        |                          |
        |                          |
        |                          |
        +--------------------------+
        |
        |  +------------------+
        +--|     Classes      |
        |  |------------------|
        +--| Class_ID         |
           | Class_Name       |
           | Teacher_ID      |
           +------------------+
                   |
                   |
                   |
                   +---------------------+
                   |     Enrollments     |
                   |---------------------|
                   | Enrollment_ID       |
                   | Student_ID          |
                   | Class_ID            |
                   +---------------------+
```

▎3. Реализация базы данных в Excel

▎Шаг 1: Создание таблиц

1. Таблица Students:

   • В ячейках A1:D1 введите заголовки: Student_ID, Name, Age.

   • Заполните данные ниже заголовков.

2. Таблица Teachers:

   • В ячейках F1:H1 введите заголовки: Teacher_ID, Name, Subject.

   • Заполните данные ниже заголовков.

3. Таблица Classes:

   • В ячейках J1:L1 введите заголовки: Class_ID, Class_Name, Teacher_ID.

   • Заполните данные ниже заголовков.

4. Таблица Enrollments:

   • В ячейках N1:P1 введите заголовки: Enrollment_ID, Student_ID, Class_ID.

   • Заполните данные ниже заголовков.

▎Шаг 2: Форматирование таблиц

• Выделите строки с заголовками и примените жирный шрифт.

• Установите фильтры для заголовков через вкладку "Данные" -> "Фильтр".

▎Шаг 3: Задание диапазонов имен

• Выделите каждую таблицу и задайте ей имя через "Формулы" -> "Определить имя". Это поможет вам использовать формулы и ссылки.

▎Шаг 4: Использование формул для связи данных

Для получения информации о студенте или классе по ID вы можете использовать формулу VLOOKUP.

Пример для получения имени студента по его ID в таблице Enrollments:

• В ячейке Q2 (например, рядом с таблицей Enrollments):
```excel
=VLOOKUP(B2, Students!A:C, 2, FALSE)
```
Это вернет имя студента по его ID.

## Создание и настройка бд

Dbeaver + sqlight

SQLite — это легковесная реляционная база данных, которая хранит данные в одном файле и не требует отдельного сервера для работы. Она очень удобна для разработки, тестирования и малых приложений. DBeaver — это мощный инструмент для работы с различными базами данных, включая SQLite.

▎Пример базы данных и SQL-скрипта

Допустим, у вас есть база данных для простого приложения управления задачами (To-Do List). В этой базе данных у нас будет одна таблица tasks, которая будет содержать следующие поля:

• id — уникальный идентификатор задачи (INTEGER, PRIMARY KEY)

• task — текст задачи (TEXT)

• is_completed — статус выполнения задачи (BOOLEAN)

• created_at — дата создания задачи (DATETIME)

▎SQL-скрипт для создания таблицы и работы с ней

Вот пример SQL-скрипта для создания таблицы, добавления задач и выборки данных:

```sql
-- Создание таблицы tasks
CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task TEXT NOT NULL,
    is_completed BOOLEAN NOT NULL DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Вставка новых задач
INSERT INTO tasks (task, is_completed) VALUES ('Купить продукты', 0);
INSERT INTO tasks (task, is_completed) VALUES ('Сделать домашнее задание', 0);
INSERT INTO tasks (task, is_completed) VALUES ('Позвонить другу', 0);

-- Получение всех задач
SELECT * FROM tasks;

-- Обновление статуса выполнения задачи
UPDATE tasks SET is_completed = 1 WHERE id = 1;

-- Удаление задачи
DELETE FROM tasks WHERE id = 3;

-- Получение всех задач с фильтром по статусу
SELECT * FROM tasks WHERE is_completed = 0;
```

▎Пояснение к скрипту

1. Создание таблицы: 

   • CREATE TABLE IF NOT EXISTS tasks создает таблицу tasks, если она еще не существует.

   • Поля определены с соответствующими типами данных.

2. Вставка задач: 

   • Используем INSERT INTO для добавления новых записей в таблицу.

3. Выборка задач: 

   • Команда SELECT * FROM tasks извлекает все записи из таблицы.

4. Обновление статуса задачи: 

   • UPDATE изменяет статус выполнения задачи по указанному id.

5. Удаление задачи: 

   • DELETE FROM удаляет задачу по заданному id.

6. Фильтрация задач: 

   • Запрос SELECT * FROM tasks WHERE is_completed = 0 позволяет получить только незавершенные задачи.

▎Запуск скрипта в DBeaver

1. Откройте DBeaver и подключитесь к вашей базе данных SQLite.

2. Создайте новый SQL-скрипт через File -> New -> SQL Editor.

3. Скопируйте и вставьте вышеуказанный скрипт в редактор.

4. Выделите весь текст скрипта и нажмите кнопку "Выполнить" или используйте сочетание клавиш (обычно Ctrl + Enter).

5. Посмотрите результаты выполнения в нижней панели.

## Работа с БД.

```python
import sqlalchemy as sa
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

# Определяем базовый класс для моделей
Base = declarative_base()

# Определяем модель задачи
class Task(Base):
    __tablename__ = 'tasks'

    id = Column(Integer, primary_key=True, autoincrement=True)
    task = Column(String, nullable=False)
    is_completed = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)

# Создаем базу данных SQLite
engine = create_engine('sqlite:///todo_list.db')
Base.metadata.create_all(engine)

# Создаем сессию для работы с базой данных
Session = sessionmaker(bind=engine)
session = Session()

# Функция для добавления новой задачи
def add_task(task_text):
    new_task = Task(task=task_text)
    session.add(new_task)
    session.commit()
    print(f'Задача добавлена: {task_text}')

# Функция для получения всех задач
def get_tasks():
    tasks = session.query(Task).all()
    for task in tasks:
        print(f'ID: {task.id}, Задача: {task.task}, Выполнено: {task.is_completed}, Дата создания: {task.created_at}')

# Функция для обновления статуса задачи
def complete_task(task_id):
    task = session.query(Task).filter(Task.id == task_id).first()
    if task:
        task.is_completed = True
        session.commit()
        print(f'Задача с ID {task_id} отмечена как выполненная.')
    else:
        print(f'Задача с ID {task_id} не найдена.')

# Функция для удаления задачи
def delete_task(task_id):
    task = session.query(Task).filter(Task.id == task_id).first()
    if task:
        session.delete(task)
        session.commit()
        print(f'Задача с ID {task_id} удалена.')
    else:
        print(f'Задача с ID {task_id} не найдена.')

# Пример использования функций
if __name__ == '__main__':
    add_task('Купить продукты')
    add_task('Сделать домашнее задание')
    add_task('Позвонить другу')
    
    print("\nВсе задачи:")
    get_tasks()
    
    complete_task(1)  # Обновляем статус первой задачи
    
    print("\nВсе задачи после обновления:")
    get_tasks()
    
    delete_task(3)  # Удаляем третью задачу
    
    print("\nВсе задачи после удаления:")
    get_tasks()

# Закрываем сессию
session.close()
```

▎Пояснение к коду

1. Импорт библиотек: Импортируем необходимые модули из SQLAlchemy и стандартную библиотеку datetime.

2. Определение модели: Создаем класс Task, который наследуется от Base. Этот класс представляет таблицу tasks в базе данных.

3. Создание базы данных: Создаем объект engine, который подключается к базе данных SQLite. Затем создаем таблицы в базе данных с помощью Base.metadata.create_all(engine).

4. Создание сессии: Создаем сессию для взаимодействия с базой данных.

5. Функции:

   • add_task(): Добавляет новую задачу в базу данных.

   • get_tasks(): Извлекает и выводит все задачи.

   • complete_task(): Обновляет статус выполнения задачи по id.

   • delete_task(): Удаляет задачу по id.

6. Пример использования: В блоке if __name__ == '__main__': добавляем несколько задач, выводим их, обновляем статус одной из задач и удаляем другую.
